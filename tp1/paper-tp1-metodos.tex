\documentclass[10pt,a4paper]{article}
\usepackage[spanish]{babel}%corta palabras en español
\usepackage[latin1]{inputenc}%escribir con acentos, ñ
\begin{document}
$$ \mbox{\bf Universidad de Buenos Aires} $$
$$ \mbox{Facultad de Ciencias Exáctas y Naturales} $$
$$ \mbox{(FCEyN)} $$
$$ \mbox{Departamento de Computación} $$

{\large Trabajo Práctico Número 1: Espía por error (numérico)}

\medskip


{González Sergio (gonzalezsergio2003@yahoo.com.ar)}

{González Emiliano (XJesse\_JamesX@hotmail.com)}

{Mariano (eltrencitomasverde@gmail.com)}

\medskip
Palábras clave:

Resúmen:
\medskip

\pagebreak
\leftline {\bf Introducción:}
El análisis numérico básicamente se encarga de analizar, describir y crear algoritmos numéricos que permiten resolver problemas matemáticos. Estos algoritmos generalmente nos permiten obtener resultados aproximados, ya que contienen un número finito de pasos. El uso del análisis numérico toma gran
importancia con el uso de las computadoras y el poder de calculo que ellas tienen. Por este medio, es posible resolver problemas mas complejos.

Pero el uso de computadoras para hacer cálculos complejos trae un problema con sigo, y surge el concepto de error. Este concepto nace debido a que las computadoras trabajan con un rango finito de números, y además cada uno de estos está representado de una forma también finita.


Los errores están divididos en trés tipos: Errores en los datos de entrada, errores de redondeo y errores de truncamiento. Los errores en los datos de entrada no están causados por el algoritmo que resuelve el problema, sino por valores que inician el algoritmo, generalmente estos valores se refieren a mediciones o magnitudes físicas. Los errores de redondeo surgen cuando se utilizan operaciones que tienen una representación numerica finita, esto significa que tienen una precisión limitada con respecto al resultado que devuelven. Y los errores de truncamiento están relacionados con el algoritmo en si, esto quiere decir que dependen de la forma en que se resuelve el problema, en algunos casos el error de truncamiento se puede disminuir modificando o refinando el algoritmo, esto generalmente implica aumentar la cantidad de
operaciones a hacer y por lo tanto aumentar el error de redondeo y el tiempo para resolver el problema.


El uso de computadoras en el cálculo numérico no solo conduce a errores de los antes mencionados, sino que, impulsado por alguno de los anteriores, aparece el error por resolver el probléma no como se ha formulado, sino a través de alguna aproximación. Este error es causado por reemplazar un infinito(sumatoria
o integral por ejemplo) por una cantidad finita de términos La precisión finita que introduce algunos de los errores numéricos, es la que opera bajo el estándar de la IEEE (Institute of Electrical and Electronics Engineers) nro. 754, que normaliza la notación en bits de los numeros de punto flotante, la norma tiene cuatro grados de precisión: simple \(32 bits\), simple extendida(43 bits, no se utiliza habitualmente), doble (64) y doble extendida (implementada en 80 bits o más). Todas las normas cuentan con tres campos: signo, mantisa y exponente, los dos últimos varian su longitud según de cual se trate. En el caso de la doble extendida, se asigna un bit al signo (la parte más alta de la cadena), 64 a la mantisa (que se almacena en la parte baja de la cadena en notación sin signo) y 15 al exponente(entre las otras dos, se encuentra desplazado 2\^{}(14) ). El rango representado es [-10\^{}(4932), 10\^{}(4932)] aprox.

A su vez, existen varias maneras de cuantificar el error, de forma que su medición se torne algo más tangible y útil, entre ellas, el error relativo y el error absoluto son las que trataremos en este trabajo. Desde el punto de vista absoluto, el error surge de la diferencia que pudiera haber entre la magnitud real que se desea expresar, y la obtenida mediante cálculos computacionales. Por otra parte el error relativo tiene en cuenta no solo las magnitudes, sino el cociente entre la diferencia anterior y el valor absoluto de la magnitud
medida. De esta forma se obtiene una real dimensión del error y no tan solo el valor absoluto del mismo. Por estos motivos, una de las tareas del análisis numerico se trata de buscar un algoritmo que lleve a la mejor solución posible de cada problema. De esta forma se pueden definir muchos algoritmos que lleguen a la solución, pero se seleccionará el que mejor aproxime a la solución del problema, es decir, el que mejor utilice las operaciones respecto de sus errores.

En este caso surge la noción de estabilidad numérica. La estabilidad numérica define cuan buena será la solución de nuestro problema usando métodos aproximados. Estos métodos pueden tener un resultado diferente al esperado, ya que tienen diferente estabilidad numerica, esto quiere decir que para ciertos
valores de entrada, con sus respectivos errores, el método puede propagar el error por el algoritmo en mayor o menor medida. De esta forma, el algoritmo que mejor aproxime a la solución del problema, será aquel que tenga mejor estabilidad numerica.

\medskip
\leftline{\bf Desarrollo:}

El problema puntual abordado por este trabajo es obtener una aproximación de la función e\^{}(-x), mediante el polinomio de Taylor. El desarrollo de este algoritmo contempla dos variantes:

\begin{enumerate}
\item Desarrollar la función f(x) = e\^{}(-x)en serie de Taylor alrededor del 0, y evaluar esta serie en el punto x = a.

\item Desarrollar la función f(x) = e\^{}x en serie de Taylor alrededor del 0, evaluar esta serie en el punto x = a y responder la inversa del valor calculado.
\end{enumerate}

\leftline{En cualquier caso, se incurre en varios tipos de error, a saber:}
\begin{enumerate}
\item Error debido a la implementación en aritmetica finita 
\item Error de truncamiento en cuanto a que el polinomio de Taylor es una serie, por tanto infinita, de términos, que se verá acotada a la cantidad que el usuario considere conveniente.
\end{enumerate}

Es condición para el trabajo realizar la aritmetica con precisión arbitraria (no por eso pierde su calidad de finita), determinada por el usuario. Entiéndase por precisión, el numero de bits de la mantisa en notación normalizada, esta cantidad esta acotada (en este trabajo) superiormente por 64.

El resultado de analizar las magnitudes y los comportamientos de los errores introducidos por el polinomio de Taylor para el calculo de la función serán abordados en este mismo trabajo, más adelante.

\medskip
\leftline{\bf Detalles de implementación:}

Como la condicion del trabajo es obtener el valor de la funcion e\^{}(-x) impementando una aritmetica de precision arbitraria, comenzamos pensando como es que realmente ibamos a implementarla. Luego de algunas reflexiones, llegamos a dilucidar dos formas diferentes. La primera, era diseñar e implementar desde cero, un aritmetica arbitraria adaptada al problema que se queria resolver. La segunda, utilizar la aritmetica fija que nos provee la PC como base y modificarla de alguna manera para que tenga la propiedad de ser arbitraria.

Comenzamos planteando la primer opcion, buscando una manera de representar los datos. No hubo divergencia en cuanto a este tema, ya que solo una forma de representación nos vino a la mente, la de utilizar un arreglo de caracteres del tamaño que el usuario indicara para la cantidad de digitos en la mantisa, más los del exponente y el signo. Este arreglo contrendría ceros y unos, y codificaría cada numero a representar, ya sea por ingreso manual del dato o como resultado de alguna funcion del sistema a implementar.

El formato a utilizar para almacenar los datos dentro del arreglo iva a estar basado en el estandar IEEE numero 754. Es decir, que el arreglo tendria tres partes, una parte para el signo, otra para el exponente y otra para la mantisa. En principio, un problema que se nos planteo era el de saber o determinar cuantos "bits" tendria asignado el exponente, por el signo y la mantisa no tendrian ningun inconveniente, ya que tendrian un bit y la cantidad ingresada por el usuario respectivamente. Como nuestra idea era conseguir una mejor presicion a la hora de resolver el problema, decidimos asignarle la misma cantidad de bits que usa el estandar IEEE numero 754 en su version extendida, ya que consideramos esa cantidad ni muy pobre ni muy exesiva a la hora de hacer los calculos.

Finalmente, consideramos muy complicado implementar esta opcion, por lo que decistimos de utilizarla.

Planteamos la segunda opcion, y de inmediato nos percatamos de que era relativamente mas facil de implementar que la opcion uno, pero con el inconveniente de que la cantidad de bits en la mantisa estaba limitada superiormente. Esto nos permitio saber que ivamos a tener una cota con respecto a la presicion que iva a requerir el usuario. De todas formas, a pesar del inconveniente comentado, nos parecio mas seguro con respecto a los calculos, trabajar con una representacion que ya estaba acentada y por lo tanto funcionando.
\end{document}
